# Action Sequencing

## Introduction

Action sequencing is the process of converting cognitive plans generated by LLMs into executable sequences of ROS 2 actions. This involves mapping high-level planning concepts to specific robot capabilities and ensuring proper execution order with dependency management.

## Understanding Action Sequences

### Definition and Purpose

An action sequence is an ordered list of executable robot actions derived from a cognitive plan. Each action in the sequence:
- Corresponds to a specific robot capability
- Has defined parameters and expected outcomes
- May have dependencies on previous actions
- Includes error handling and recovery procedures

### Characteristics of Good Action Sequences

1. **Executable**: Each action must correspond to an actual robot capability
2. **Ordered**: Actions must follow logical sequence respecting dependencies
3. **Robust**: Include error handling and fallback procedures
4. **Optimized**: Minimize unnecessary actions while achieving goals
5. **Safe**: Respect environmental and safety constraints

## ROS 2 Action Architecture

### Action Server and Client Pattern

ROS 2 uses the action server/client pattern for long-running tasks:

```python
import rclpy
from rclpy.action import ActionClient, ActionServer
from rclpy.node import Node
from your_msgs.action import NavigateToPose, ManipulateObject
import threading

class ActionSequencer(Node):
    def __init__(self):
        super().__init__('action_sequencer')

        # Action clients for different robot capabilities
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.manip_client = ActionClient(self, ManipulateObject, 'manipulate_object')

        # Service for executing action sequences
        self.seq_service = self.create_service(
            ExecuteActionSequence,
            'execute_action_sequence',
            self.execute_sequence_callback
        )

    def execute_sequence_callback(self, request, response):
        """
        Execute a sequence of actions
        """
        try:
            sequence = request.action_sequence
            success = self.execute_action_sequence(sequence)
            response.success = success
            response.message = "Sequence completed" if success else "Sequence failed"
        except Exception as e:
            response.success = False
            response.message = f"Error: {str(e)}"

        return response

    def execute_action_sequence(self, actions):
        """
        Execute a sequence of actions with dependency management
        """
        for i, action in enumerate(actions):
            self.get_logger().info(f"Executing action {i+1}/{len(actions)}: {action.type}")

            success = self.execute_single_action(action)
            if not success:
                self.get_logger().error(f"Action {i+1} failed: {action.type}")
                return False

        return True
```

### Action Definition and Structure

```python
from dataclasses import dataclass
from typing import Dict, Any, List
from enum import Enum

class ActionType(Enum):
    NAVIGATE = "navigate"
    MANIPULATE = "manipulate"
    DETECT = "detect"
    SPEAK = "speak"
    WAIT = "wait"

@dataclass
class RobotAction:
    action_type: ActionType
    parameters: Dict[str, Any]
    dependencies: List[int]  # Indices of actions that must complete first
    timeout: float = 30.0
    fallback_action: 'RobotAction' = None

class ActionSequence:
    def __init__(self, actions: List[RobotAction]):
        self.actions = actions
        self.results = [None] * len(actions)

    def validate_dependencies(self) -> bool:
        """
        Validate that all dependencies are valid
        """
        for i, action in enumerate(self.actions):
            for dep_idx in action.dependencies:
                if dep_idx >= i:  # Dependency must come before current action
                    return False
                if dep_idx < 0:
                    return False
        return True
```

## Converting Cognitive Plans to Action Sequences

### Plan Parsing and Conversion

```python
class PlanToActionConverter:
    def __init__(self):
        self.action_mapping = {
            "NAVIGATE": self._create_navigate_action,
            "DETECT_OBJECT": self._create_detect_action,
            "GRASP_OBJECT": self._create_grasp_action,
            "PLACE_OBJECT": self._create_place_action,
            "SAY": self._create_speak_action,
            "WAIT": self._create_wait_action
        }

    def convert_plan_to_sequence(self, cognitive_plan: Dict[str, Any]) -> ActionSequence:
        """
        Convert cognitive plan to executable action sequence
        """
        actions = []

        for i, plan_step in enumerate(cognitive_plan.get("plan", [])):
            action_type = plan_step["action"]
            parameters = plan_step.get("parameters", {})

            if action_type in self.action_mapping:
                action = self.action_mapping[action_type](parameters)
                action.dependencies = [i-1] if i > 0 else []  # Sequential dependencies
                actions.append(action)
            else:
                raise ValueError(f"Unknown action type: {action_type}")

        return ActionSequence(actions)

    def _create_navigate_action(self, params: Dict[str, Any]) -> RobotAction:
        """
        Create navigation action from parameters
        """
        return RobotAction(
            action_type=ActionType.NAVIGATE,
            parameters={
                "target_pose": params.get("target_pose"),
                "frame_id": params.get("frame_id", "map")
            },
            timeout=60.0
        )

    def _create_detect_action(self, params: Dict[str, Any]) -> RobotAction:
        """
        Create object detection action
        """
        return RobotAction(
            action_type=ActionType.DETECT,
            parameters={
                "object_type": params.get("object_type"),
                "search_area": params.get("search_area")
            },
            timeout=20.0
        )

    def _create_grasp_action(self, params: Dict[str, Any]) -> RobotAction:
        """
        Create object grasping action
        """
        return RobotAction(
            action_type=ActionType.MANIPULATE,
            parameters={
                "action": "grasp",
                "object_pose": params.get("object_pose"),
                "grasp_type": params.get("grasp_type", "precision")
            },
            timeout=30.0
        )

    def _create_place_action(self, params: Dict[str, Any]) -> RobotAction:
        """
        Create object placement action
        """
        return RobotAction(
            action_type=ActionType.MANIPULATE,
            parameters={
                "action": "place",
                "target_pose": params.get("target_pose"),
                "placement_type": params.get("placement_type", "careful")
            },
            timeout=30.0
        )

    def _create_speak_action(self, params: Dict[str, Any]) -> RobotAction:
        """
        Create speech action
        """
        return RobotAction(
            action_type=ActionType.SPEAK,
            parameters={
                "text": params.get("text", ""),
                "voice_type": params.get("voice_type", "default")
            },
            timeout=10.0
        )

    def _create_wait_action(self, params: Dict[str, Any]) -> RobotAction:
        """
        Create wait action
        """
        return RobotAction(
            action_type=ActionType.WAIT,
            parameters={
                "duration": params.get("duration", 1.0)
            },
            timeout=params.get("duration", 1.0) + 1.0
        )
```

## Advanced Sequencing Patterns

### Parallel Action Execution

For actions that can run in parallel:

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class ParallelActionSequencer:
    def __init__(self, node):
        self.node = node
        self.executor = ThreadPoolExecutor(max_workers=5)

    async def execute_parallel_sequence(self, action_sequence: ActionSequence):
        """
        Execute actions that can run in parallel based on dependencies
        """
        remaining_actions = list(enumerate(action_sequence.actions))
        completed = set()
        results = [None] * len(action_sequence.actions)

        while remaining_actions:
            # Find actions whose dependencies are satisfied
            ready_actions = []
            for idx, action in remaining_actions:
                deps_satisfied = all(dep in completed for dep in action.dependencies)
                if deps_satisfied:
                    ready_actions.append((idx, action))

            if not ready_actions:
                raise RuntimeError("Circular dependency detected in action sequence")

            # Execute ready actions in parallel
            tasks = []
            for idx, action in ready_actions:
                task = asyncio.get_event_loop().run_in_executor(
                    self.executor, self.execute_single_action, idx, action
                )
                tasks.append((idx, task))

            # Wait for all parallel tasks to complete
            for idx, task in tasks:
                result = await task
                results[idx] = result
                completed.add(idx)

            # Remove completed actions from remaining
            remaining_actions = [(idx, action) for idx, action in remaining_actions
                               if idx not in completed]

        return results
```

### Conditional Action Sequences

```python
class ConditionalActionSequencer:
    def execute_conditional_sequence(self, sequence: ActionSequence,
                                   condition_checker: callable) -> bool:
        """
        Execute sequence with conditional branching
        """
        for i, action in enumerate(sequence.actions):
            # Check if action should be executed based on conditions
            if hasattr(action, 'condition') and action.condition:
                if not condition_checker(action.condition):
                    self.node.get_logger().info(f"Skipping action {i} due to condition")
                    continue

            success = self.execute_single_action(action)
            if not success and not action.fallback_action:
                return False
            elif not success and action.fallback_action:
                fallback_success = self.execute_single_action(action.fallback_action)
                if not fallback_success:
                    return False

        return True
```

## Error Handling and Recovery

### Comprehensive Error Handling

```python
from enum import Enum

class ExecutionResult(Enum):
    SUCCESS = "success"
    FAILURE = "failure"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"

class RobustActionSequencer:
    def execute_single_action_with_retry(self, action: RobotAction,
                                       max_retries: int = 3) -> ExecutionResult:
        """
        Execute action with retry logic
        """
        for attempt in range(max_retries):
            try:
                result = self.execute_single_action(action)
                if result:
                    return ExecutionResult.SUCCESS
                else:
                    self.node.get_logger().warn(f"Action failed on attempt {attempt + 1}")
            except Exception as e:
                self.node.get_logger().error(f"Action error on attempt {attempt + 1}: {e}")

            if attempt < max_retries - 1:
                # Wait before retry
                time.sleep(1.0)

        return ExecutionResult.FAILURE

    def execute_sequence_with_recovery(self, sequence: ActionSequence) -> bool:
        """
        Execute sequence with recovery procedures
        """
        for i, action in enumerate(sequence.actions):
            result = self.execute_single_action_with_retry(action)

            if result == ExecutionResult.SUCCESS:
                continue
            elif result == ExecutionResult.FAILURE and action.fallback_action:
                # Try fallback action
                fallback_result = self.execute_single_action_with_retry(action.fallback_action)
                if fallback_result != ExecutionResult.SUCCESS:
                    self.node.get_logger().error(f"Fallback action failed for action {i}")
                    return False
            else:
                self.node.get_logger().error(f"Action {i} failed without recovery")
                return False

        return True
```

## Performance Optimization

### Action Preprocessing and Validation

```python
class OptimizedActionSequencer:
    def preprocess_sequence(self, sequence: ActionSequence) -> ActionSequence:
        """
        Optimize action sequence before execution
        """
        # Remove redundant actions
        optimized_actions = self._remove_redundant_actions(sequence.actions)

        # Optimize navigation paths
        optimized_actions = self._optimize_navigation(optimized_actions)

        # Validate action sequence
        if not self._validate_sequence(optimized_actions):
            raise ValueError("Invalid action sequence after optimization")

        return ActionSequence(optimized_actions)

    def _remove_redundant_actions(self, actions: List[RobotAction]) -> List[RobotAction]:
        """
        Remove redundant or conflicting actions
        """
        # Implementation would identify and remove redundant actions
        # For example: multiple navigation actions to the same location
        # Or conflicting manipulation actions
        pass

    def _optimize_navigation(self, actions: List[RobotAction]) -> List[RobotAction]:
        """
        Optimize navigation actions for efficiency
        """
        # Combine multiple navigation actions to nearby locations
        # Optimize path planning
        pass
```

## Integration with Cognitive Planning

### Complete Integration Example

```python
class IntegratedCognitivePlanner:
    def __init__(self):
        self.llm_planner = LLMCognitivePlanner(api_key="your-key")
        self.plan_converter = PlanToActionConverter()
        self.action_sequencer = ActionSequencer()  # ROS 2 node

    def execute_command(self, command: str, context: Dict[str, Any] = None) -> bool:
        """
        Complete pipeline: command → cognitive plan → action sequence → execution
        """
        # 1. Generate cognitive plan using LLM
        cognitive_plan = self.llm_planner.generate_plan(command, context)

        if not cognitive_plan or not cognitive_plan.get("plan"):
            self.action_sequencer.get_logger().error("No plan generated")
            return False

        # 2. Convert plan to action sequence
        try:
            action_sequence = self.plan_converter.convert_plan_to_sequence(cognitive_plan)
        except Exception as e:
            self.action_sequencer.get_logger().error(f"Plan conversion failed: {e}")
            return False

        # 3. Validate action sequence
        if not action_sequence.validate_dependencies():
            self.action_sequencer.get_logger().error("Invalid action dependencies")
            return False

        # 4. Execute action sequence
        success = self.action_sequencer.execute_action_sequence(action_sequence.actions)

        return success
```

## Summary

Action sequencing bridges the gap between high-level cognitive planning and low-level robot execution. Effective action sequencing requires careful consideration of dependencies, error handling, and optimization. The next section will explore the complete implementation of cognitive planning systems that tie together LLM integration and action sequencing.